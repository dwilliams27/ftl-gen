# XML Modding Limits

Honest reference for what Slipstream XML patching can and can't do. Everything here reflects actual testing with ftl-gen-produced mods.

## How the modding pipeline works

```
ftl-gen (LLM + sprites)
    ↓
ModContent (Pydantic models)
    ↓
ModBuilder.build()  →  .ftl ZIP (XML + sprites)
    ↓
SlipstreamManager.patch()  →  patches ftl.dat on disk
    ↓
FTL reads ftl.dat at startup  →  items available in-game
```

- `ModBuilder.build()` in `core/mod_builder.py` converts Pydantic models to XML via `XMLBuilder`, writes sprite files, and packages everything into a `.ftl` ZIP.
- `SlipstreamManager.patch()` in `core/slipstream.py` invokes the Slipstream Mod Manager JAR to merge `.xml.append` files into FTL's `ftl.dat` resource archive.
- FTL reads `ftl.dat` once at startup. All XML data must be valid at load time or the game freezes/crashes.

## What fully works

**Weapons** — All stats are data-driven and respected by the game engine. Custom sprites display correctly.
- Type, damage, cooldown, power, cost, rarity, shots, fire chance, breach chance, ion damage, beam length, missile cost
- 12-frame weapon sprite sheets (16x60 per frame) via `animations.xml.append`
- Weapons appear in stores and function identically to vanilla weapons
- `XMLBuilder.build_weapon()` handles type mapping (ION→LASER+`<ion>`, BURST→LASER)

**Drones** — Stats are data-driven. Custom body images display correctly.
- Type, power, cost, cooldown, speed, rarity
- 64x64 body images placed in `img/ship/drones/`
- Drones appear in stores and function as expected

**Crew stats** — Health, movement speed, repair speed, damage multiplier, and cost are all respected.
- Custom crew races can be defined with modified stat values
- Stats apply correctly when crew is placed on a ship

## What is cosmetic only: Augments

**This is the critical finding.** The `augBlueprint` XML controls how an augment appears in stores:
- Name (internal ID), title (display name), description, cost, rarity, stackable flag
- The `value` field (a float, e.g. `0.15` for 15% scrap bonus)

**But augment effects are hardcoded in the FTL binary.** The game has an internal dispatch table (likely a switch statement or function pointer map in C++) that maps known augment names to effect functions. For example:
- `SCRAP_COLLECTOR` → 15% bonus scrap on pickup
- `EXPLOSIVE_REPLICATOR` → 50% chance to not consume a missile
- `LONG_RANGED_SCANNERS` → reveal hazards and ship contents

A custom augment named `TRIFORCE_RESONATOR` will:
- Appear in stores with the correct name, description, cost, and rarity
- Be purchasable by the player
- Show up in the player's augment inventory
- **Do absolutely nothing mechanically** — the binary doesn't recognize the name, so no effect fires

**XML-only workaround:** Reskin a vanilla augment. Keep the internal `name` (e.g. `SCRAP_COLLECTOR`) but change the `title`, `desc`, and `cost`. The vanilla effect still fires because the binary matches on `name`. This gives the illusion of a custom augment but you're limited to the ~30 vanilla effects.

See `XMLBuilder.build_augment()` in `xml/builders.py` for the current build logic.

## What is defined but non-functional: Events

Events are generated by the LLM with choices, outcomes, rewards, and text. The XML is structurally valid. **But events are not written to the .ftl file** — they cause FTL to freeze at "Blueprints Loaded!" when patched.

The guard is in `ModBuilder._write_xml_files()` in `core/mod_builder.py`:
```python
if content.events and os.environ.get("PATCH_EVENTS") == "1":
    events_xml = self.xml_builder.build_events_append(content)
    (data_dir / "events.xml.append").write_text(events_xml)
```

Set `PATCH_EVENTS=1` to re-enable for testing. The freeze root cause is unknown — likely related to events needing proper sector hooks to be valid at load time.

Events still appear in the UI (ModDetail events tab, XML tab) for review. They just aren't patched into the game.

### What would be needed
- Root-cause the "Blueprints Loaded!" freeze (may be missing sector references, or event list format issues)
- Auto-hook events into sector definitions based on theme
- Handle conflicts with other mods that modify the same sectors

## What is partially functional: Crew spawning

Custom crew races can be defined with working stats, but:
- They **won't appear on enemy ships** — enemy crew composition is hardcoded in the binary
- They **won't appear in hiring events** — crew hiring pools are hardcoded
- The only way to get custom crew is via custom events (which don't work yet) or manual integration

## What is missing: Ships

Ship blueprints can be generated as XML, but a playable ship requires:
- `shipname.txt` — Room layout grid (ASCII art defining room positions)
- `shipname.xml` — Room definitions (systems, crew positions)
- Hull sprite, cloak sprite, shield sprite, gib sprites
- Floor image, thumbnail

The generator creates blueprint XML only. Full ship integration requires Superluminal 2 (visual editor) or manual layout creation. This is a data generation problem, not a binary limitation — a sufficiently capable image/layout generator could produce all required files.

## The augment name dispatch problem

This is the core binary limitation and the primary target for deep modding research.

**How it likely works** (NEEDS_INVESTIGATION — requires Ghidra analysis to confirm):

1. FTL loads `augBlueprint` XML entries at startup, storing name, value, cost, etc.
2. During gameplay, when an augment effect should fire (e.g., collecting scrap), the engine calls a function like `applyAugmentEffect(name, value)`.
3. That function contains a dispatch table — likely a series of `if/else` or `switch` comparisons against known augment name strings (`"SCRAP_COLLECTOR"`, `"EXPLOSIVE_REPLICATOR"`, etc.).
4. If the name matches, the corresponding effect code runs with `value` as a parameter.
5. If the name doesn't match any known entry, nothing happens — the augment is inert.

**Why this matters:** No amount of XML modding can add new augment effects. The dispatch table is compiled C++ in the binary. To add a truly new augment, you must either:
- Modify the binary to add new entries to the dispatch table (static patching)
- Intercept the dispatch function at runtime (DYLD injection, unlikely to help since it's logic not I/O)
- Use Hyperspace (which already patches the binary on Windows/Linux to support custom augment effects via Lua)

See [docs/deep-modding-research.md](deep-modding-research.md) for investigation approaches.
